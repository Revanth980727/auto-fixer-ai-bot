
from agents.base_agent import BaseAgent
from core.models import Ticket, AgentExecution, AgentType, PatchAttempt
from core.database import get_sync_db
from services.github_client import GitHubClient
from typing import Dict, Any
import subprocess
import tempfile
import os
import logging

logger = logging.getLogger(__name__)

class QAAgent(BaseAgent):
    def __init__(self):
        super().__init__(AgentType.QA)
        self.github_client = GitHubClient()
    
    async def process(self, ticket: Ticket, execution_id: int) -> Dict[str, Any]:
        """Test patches generated by developer agent"""
        self.log_execution(execution_id, "Starting QA testing process")
        
        # Get patches to test
        patches = self._get_patches_for_testing(ticket)
        
        if not patches:
            self.log_execution(execution_id, "No patches found for testing")
            return {"status": "no_patches", "patches_tested": 0}
        
        test_results = []
        
        for patch in patches:
            self.log_execution(execution_id, f"Testing patch {patch.id}")
            
            try:
                result = await self._test_patch(patch)
                test_results.append(result)
                
                # Update patch with test results
                self._update_patch_results(patch, result)
                
            except Exception as e:
                self.log_execution(execution_id, f"Error testing patch {patch.id}: {e}")
                test_results.append({
                    "patch_id": patch.id,
                    "success": False,
                    "error": str(e)
                })
        
        successful_patches = [r for r in test_results if r.get("success")]
        
        result = {
            "status": "completed",
            "patches_tested": len(test_results),
            "successful_patches": len(successful_patches),
            "test_results": test_results,
            "ready_for_deployment": len(successful_patches) > 0
        }
        
        self.log_execution(execution_id, f"QA completed: {len(successful_patches)}/{len(test_results)} patches passed")
        return result
    
    def _get_patches_for_testing(self, ticket: Ticket) -> list:
        """Get patches that need testing"""
        with next(get_sync_db()) as db:
            return db.query(PatchAttempt).filter(
                PatchAttempt.ticket_id == ticket.id,
                PatchAttempt.success.is_(None)  # Not yet tested
            ).all()
    
    async def _test_patch(self, patch: PatchAttempt) -> Dict[str, Any]:
        """Test a single patch in isolated environment"""
        with tempfile.TemporaryDirectory() as temp_dir:
            try:
                # Clone repository to temp directory
                clone_success = await self._clone_repository(temp_dir)
                if not clone_success:
                    return {"patch_id": patch.id, "success": False, "error": "Failed to clone repository"}
                
                # Apply patch
                apply_success = await self._apply_patch(temp_dir, patch)
                if not apply_success:
                    return {"patch_id": patch.id, "success": False, "error": "Failed to apply patch"}
                
                # Run tests
                test_results = await self._run_tests(temp_dir, patch)
                
                return {
                    "patch_id": patch.id,
                    "success": test_results["success"],
                    "test_output": test_results["output"],
                    "error": test_results.get("error")
                }
                
            except Exception as e:
                return {"patch_id": patch.id, "success": False, "error": str(e)}
    
    async def _clone_repository(self, temp_dir: str) -> bool:
        """Clone the repository for testing"""
        try:
            repo_url = f"https://github.com/{os.getenv('GITHUB_REPO_OWNER')}/{os.getenv('GITHUB_REPO_NAME')}.git"
            
            result = subprocess.run([
                "git", "clone", repo_url, temp_dir
            ], capture_output=True, text=True, timeout=60)
            
            return result.returncode == 0
            
        except Exception as e:
            logger.error(f"Error cloning repository: {e}")
            return False
    
    async def _apply_patch(self, repo_dir: str, patch: PatchAttempt) -> bool:
        """Apply patch to the cloned repository"""
        try:
            # Write patch content to file
            patch_file = os.path.join(repo_dir, "temp.patch")
            with open(patch_file, "w") as f:
                f.write(patch.patch_content)
            
            # Apply patch
            result = subprocess.run([
                "git", "apply", patch_file
            ], cwd=repo_dir, capture_output=True, text=True, timeout=30)
            
            # Clean up patch file
            os.remove(patch_file)
            
            return result.returncode == 0
            
        except Exception as e:
            logger.error(f"Error applying patch: {e}")
            return False
    
    async def _run_tests(self, repo_dir: str, patch: PatchAttempt) -> Dict[str, Any]:
        """Run tests on the patched code"""
        try:
            # Try common test commands
            test_commands = [
                ["python", "-m", "pytest", "-v"],
                ["npm", "test"],
                ["python", "-m", "unittest", "discover"],
                ["python", "-c", f"exec('''{patch.test_code}''')"]  # Run patch-specific test
            ]
            
            for cmd in test_commands:
                try:
                    result = subprocess.run(
                        cmd, 
                        cwd=repo_dir, 
                        capture_output=True, 
                        text=True, 
                        timeout=120
                    )
                    
                    if result.returncode == 0:
                        return {
                            "success": True,
                            "output": result.stdout,
                            "command": " ".join(cmd)
                        }
                    
                except (subprocess.TimeoutExpired, FileNotFoundError):
                    continue
            
            # If no tests passed, return failure
            return {
                "success": False,
                "output": "No tests executed successfully",
                "error": "Test execution failed"
            }
            
        except Exception as e:
            return {
                "success": False,
                "output": "",
                "error": str(e)
            }
    
    def _update_patch_results(self, patch: PatchAttempt, test_results: Dict):
        """Update patch with test results"""
        with next(get_sync_db()) as db:
            patch.success = test_results.get("success", False)
            patch.test_results = test_results
            db.add(patch)
            db.commit()
